#+TITLE: Stumpwm configuration
#+AUTHOR: Cloud Strife (Spektrum_light, gear-piped, purity-interface, topological android GAR-XB/G-3778 id: MGlIGTfxzZ formula-spectre)
#+PROPERTY: header-args :tangle "~/.config/stumpwm/config" :mkdirp t :shebang ";; -*- mode: lisp -*- \n"
#+auto_tangle: t
*  this is my stumpwm configuration. batteries included, but not charged. please escuse my wonkiness on common lisp.  feel free to take this as inspiration and/or contribute!

** load quicklisp
#+BEGIN_SRC lisp
#-quicklisp
(let ((quicklisp-init (merge-pathnames ".local/share/quicklisp/setup.lisp"
                                       (user-homedir-pathname))))
  (when (probe-file quicklisp-init)
    (load quicklisp-init)))
#+END_SRC

** load slynk/swank
#+BEGIN_SRC lisp
(ql:quickload :slynk)
(ql:quickload :swank)
(let ((server-running nil))
  (defcommand slynk () ()
    "Toggle the swank server on/off"
    (if server-running
	(progn
	  (swank:stop-server 4005)
	  (echo-string
	   (current-screen)
	   "Stopping swank.")
	  (setf server-running nil))
	(progn
	  (swank:create-server :port 4005
			       :style swank:*communication-style*
			       :dont-close t)
	  (echo-string
	   (current-screen)
	   "Starting swank. M-x slime-connect RET RET, then (in-package stumpwm).")
	  (setf server-running t)))))
#+END_SRC

** define some colors.
#+BEGIN_SRC lisp
(defvar *background* "#000000")
(defvar *foreground* "#FFFFFF")
#+END_SRC
** macros!
*** define a macro to make generate emacs commands
#+BEGIN_SRC lisp
(defmacro emacs-cmd (name emacs-command)
  "a macro that permits to easily define emacs commands"
    `(defcommand ,name () ()
       (emacs)
       (meta (kbd "M-x"))
..»       (window-send-string ,emacs-command)
       (meta (kbd "RET"))))
#+END_SRC
**** emacs commands
#+BEGIN_SRC lisp
(emacs-cmd emacs-magit    "magit")
(emacs-cmd emacs-calendar "=calendar")
#+END_SRC
*** define a macro to make mapping to various maps (heh) easier
#+BEGIN_SRC lisp
(defmacro mmap (map key command)
  "a macro to make binding easier"
  `(define-key ,map (kbd ,key) ,command))
#+END_SRC

**  keybindings
***  make focus follow mouse
#+BEGIN_SRC lisp
(setf *mouse-focus-policy* :sloppy)
#+END_SRC

*** define a custom keymap for my most used applications
#+BEGIN_SRC lisp
(defvar *my-application-keymap*
  (let ((m (make-sparse-keymap)))
    (mmap m "l" "exec librewolf")
    (mmap m "c" "exec chromium")
    (mmap m "s" "exec slack")
    (mmap m "t" "exec boxxy thunderbird")
    (mmap m "C-t" "exec trello")
    (mmap m "C-a" "exec trello exec boxxy thunderbird exec slack")
  m))
#+END_SRC
*** define a custom keymap for emacs commands
#+BEGIN_SRC lisp
(defvar *emacs-application-keymap*
   (let ((m (make-sparse-keymap)))
    (mmap m "m" "emacs-magit")
    (mmap m "c" "emacs-calendar")
  m))

#+END_SRC
*** set the prefix to mod-x, to emulate emacs.
#+BEGIN_SRC lisp
(set-prefix-key (kbd "s-x"))
#+END_SRC
*** activate which key mode, which could be helpful.
#+BEGIN_SRC lisp
(unless (which-key-mode)
  (which-key-mode))
#+END_SRC
*** *root-map* keybindings, aka prefixed ones (see prefix-key)
#+BEGIN_SRC lisp
(mmap *root-map* "x"       '*my-application-keymap*)
(mmap *root-map* "1"       "remove-split")
(mmap *root-map* "2"       "vsplit")
(mmap *root-map* "3"       "hsplit")
(mmap *root-map* "0"       "remove-split")
(mmap *root-map* "s-b"     "windowlist")
(mmap *root-map* "s"       "slynk")
(mmap *root-map* "d"       "time")
(mmap *root-map* "RET"     "exec emacsclient -ce '(eshell)'")
(mmap *root-map* "C-RET"   "exec emacsclient -ce '(+stumpish-vterm/here)'")
(mmap *root-map* "s-h"     "move-window left")
(mmap *root-map* "s-j"     "move-window down")
(mmap *root-map* "s-k"     "move-window up")
(mmap *root-map* "s-l"     "move-window right")
(mmap *root-map* "C-e"      '*emacs-application-keymap*)
#+END_SRC
*** *top-level* keybindings, aka with no prefix
#+BEGIN_SRC lisp
(mmap *top-map*  "s-RET"     "exec emacsclient -ce '(+vterm/here \"~/\")'")
(mmap *top-map*  "s-h"       "move-focus left")
(mmap *top-map*  "s-j"       "move-focus down")
(mmap *top-map*  "s-k"       "move-focus up")
(mmap *top-map*  "s-l"       "move-focus right")
(mmap *top-map*  "s-p"       "exec")
(mmap *top-map*  "s-r"       "loadrc")
(mmap *top-map*  "s-:"       "eval")
#+END_SRC
**  modeline
**** formatting
here I format most of the modeline.
#+BEGIN_SRC lisp
(setf *mode-line-timeout* 1)
(setf *time-modeline-string* "%b %a %d (%H:%M:%S)")
;; set window title, truncate after 5 chars
(setf *window-format* "%n: %5t")
#+END_SRC
**** color the modeline!
#+BEGIN_SRC lisp
(let ((black "#000000")
      (white "#FFFFFF"))
  (setf *mode-line-background-color* black
        *mode-line-foreground-color* white
        *mode-line-border-color* white
        *mode-line-border-width 1)
        *mode-line-border-width 1)
#+END_SRC
**** load some modules
#+BEGIN_SRC lisp
(load-module "battery-portable")
(load-module "cpu")
(load-module "mem")
#+END_SRC
**** format the various elements of the modeline
#+BEGIN_SRC lisp
(setf cpu::*cpu-modeline-fmt*        "%c"
      cpu::*cpu-usage-modeline-fmt*  "~A~2D%"
      mem::*mem-modeline-fmt*        "%a%p"
      *hidden-window-color*          "^**"
      *mode-line-highlight-template* "«~A»")
#+END_SRC
*** format the status line
#+BEGIN_SRC lisp

(setf stumpwm:*screen-mode-line-format*
      (list ;;"[%g]"
            "[%W]"
            "[%w]"
            "^>"
            "[%d]"
            "[CPU:%C]"
            "[MEM:%M]"
;            "[BAT:%B]"
            ))
#+END_SRC


** initalization
things that have to be ran on startup.
the dbus thing is a crutch.
#+BEGIN_SRC lisp
(when *initializing*
  (progn
    (sb-ext:run-program "sh" '("~/.fehbg"))
    (sb-ext:run-program "keynav" '())
    (mode-line)))

(unless (mode-line)
  (mode-line))
(load-module "stumptray")
(stumptray::stumptray)
#+END_SRC
