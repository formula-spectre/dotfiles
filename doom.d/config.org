#+TITLE: Doom Emacs configuration
#+AUTHOR: Cloud Strife (Spektrum_light, gear-piped, purity-interface, topological android GAR-XB/G-3778 id: MGlIGTfxzZ formula-spectre)


this is my emacs configuration. it's not pretty. it's not functional. But it works for me. Deal with it
jokes aside, still working on improving both the org structure and the code itself. please do tell me that my elisp sucks, I need some CC
any help is appreciated :)

 use lexical bindings
 #+BEGIN_SRC emacs-lisp
 ;;; $DOOMDIR/config.el -*- lexical-binding: t; -*-
 #+END_SRC
*configure xmobar
this section has been stolen from the xmobar etc codeberg repo directory, all credits to jaor:

* Main emacs configuration
** theme emacs bit
*** font
 #+BEGIN_SRC emacs-lisp
(setq doom-font (font-spec :family "Iosevka Nerd Font" :size 14)
      doom-variable-pitch-font (font-spec :family "Iosevka Nerd Font" :size 15))
#+END_SRC
*** modeline
#+BEGIN_SRC emacs-lisp
(require 'doom-modeline)
(doom-modeline 1)
(setq doom-modeline-support-imenu t
      doom-modeline-height  10
      doom-modeline-hud     t
      doom-modeline-icons   t)
(setq truncate-lines nil)
#+END_SRC
*** vterm configuration
#+BEGIN_SRC emacs-lisp
(setq vterm-kill-buffer-on-exit t)
(setq vterm-term-environment-variable "xterm")
(setq vterm-shell "/bin/zsh")
#+END_SRC
*** General appearence
#+BEGIN_SRC emacs-lisp
(setq doom-theme 'cyberpunk     )
(setq doom-line-numbers-style 'relative)
(setq display-line-numbers-type 'relative)
 (setq org-directory "~/org/")
 #+END_SRC
 set my name, and my email address, plus more private things
 #+BEGIN_SRC emacs-lisp
(when (file-exists-p (concat (getenv "DOOMDIR") "/private.el"))
  (load! (concat (getenv "DOOMDIR") "/private")))
 #+END_SRC
*** doom's flavor text
  Here are some additional functions/macros that could help you configure Doom:
  - `load!' for loading external *.el files relative to this one
  - `use-package!' for configuring packages
  - `after!' for running code after a package has loaded
  - `add-load-path!' for adding directories to the `load-path', relative to
    this file. Emacs searches the `load-path' when you load packages with
    `require' or `use-package'.
  - `map!' for binding new keys
** mu4e configuration
 #+BEGIN_SRC emacs-lisp
 (when (file-directory-p "/usr/share/emacs/site-lisp/mu4e" )
   (add-to-list 'load-path "/usr/share/emacs/site-lisp/mu4e"))

  (use-package mu4e
    :ensure nil
    :load-path "/usr/share/emacs/site-lisp/mu4e/"
    ;; :defer 20 ; Wait until 20 seconds after startup
    :config

    ;; This is set to 't' to avoid mail syncing issues when using mbsync
    (setq mu4e-change-filenames-when-moving t)

    ;; Refresh mail using isync every 10 minutes
    (setq mu4e-update-interval (* 10 60))
    (setq mu4e-get-mail-command "mbsync -a")
    (setq mu4e-root-maildir "~/mail")

    (setq mu4e-drafts-folder "/[Gmail]/Drafts")
    (setq mu4e-sent-folder   "/[Gmail]/Sent Mail")
    (setq mu4e-refile-folder "/[Gmail]/All Mail")
    (setq mu4e-trash-folder  "/[Gmail]/Trash")

    (setq mu4e-maildir-shortcuts
        '(("/Inbox"             . ?i)
          ("/[Gmail]/Sent Mail" . ?s)
          ("/[Gmail]/Trash"     . ?t)
          ("/[Gmail]/Drafts"    . ?d)
         ("/[Gmail]/All Mail"  . ?a))))
 #+END_SRC
** circe configuration
#+BEGIN_SRC emacs-lisp
;TODO: encrypt the password
(require 'circe)
(setq circe-reduce-lurker-spam t)
(circe-set-display-handler "JOIN" (lambda (&rest ignored) nil))
#+END_SRC
** misc stuff
*** frog-jumper configuration
#+BEGIN_SRC emacs-lisp
(use-package frog-jump-buffer :ensure t)
(unbind-key (kbd "C-x C-b"))
(global-set-key (kbd "C-x C-b") #'frog-jump-buffer)
(global-set-key (kbd "C-x B") #'ibuffer)
(setq frog-jump-buffer-use-all-the-icons-ivy t)
(dolist (regexp '("^\\*Native-compile-log" "^\\*Async-native-compile-log" "^\\*Messages"))
  (push regexp frog-jump-buffer-ignore-buffers))
#+END_SRC
*** stumpwm configuration
this is for stumpwm, it's hacky at best
#+BEGIN_SRC emacs-lisp
(defun +stumpish-vterm/here ()
  (interactive)
  (dlet ((vterm-shell "/usr/bin/stumpish"))
    (interactive)
    (+vterm/here "~/")))

(defun stumpish-vterm ()
  (interactive)
  (dlet ((vterm-shell "/usr/bin/stumpish"))
    (interactive)
    (vterm "stumpish")))

(defun comint-stumpish ()
  (interactive)
  (comint-run "/usr/bin/stumpish"))
#+END_SRC

*** gentoo specific stuff
#+BEGIN_SRC emacs-lisp
    (when (string= (doom-system-distro) "gentoo")
(require 'portage)
(require 'magentoo))
#+END_SRC

*** TRAMP configuration
#+BEGIN_SRC emacs-lisp
(eval-after-load 'tramp '(setenv "SHELL" "/bin/bash"))
#+END_SRC
*** keybindings
**** here I define some keybindings; I use the hydra package too
***** defining hydras
****** hydra-window
#+BEGIN_SRC emacs-lisp
(cl-macrolet ((ace-lambda (number)
                          `(lambda () (interactive)
                            (ace-window ,number)
                            (add-hook 'ace-window-end-once-hook
                                      'hydra-window/body))))
 (defhydra hydra-window ()
   "
Movement^^        ^Split^         ^Switch^		^Resize^
----------------------------------------------------------------
_h_ ←       	_v_ertical    		_q_ X←
_j_ ↓        	_x_ horizontal	_f_ind files	_w_ X↓
_k_ ↑        	_z_ undo      	_a_ce 1		_e_ X↑
_l_ →        	_Z_ reset      	_s_wap		_r_ X→
_F_ollow		_D_lt Other   	_S_ave		max_i_mize
_SPC_ cancel	  	_d_elete
"
   ("h" windmove-left )
   ("j" windmove-down )
   ("k" windmove-up )
   ("l" windmove-right )
   ("q" hydra-move-splitter-left)
   ("w" hydra-move-splitter-down)
   ("e" hydra-move-splitter-up)
   ("r" hydra-move-splitter-right)
   ;("b" helm-mini)
   ("f" helm-find-files)
   ("F" follow-mode)
   ("a" (ace-lambda 1))
   ("v" (lambda ()
          (interactive)
          (split-window-right)
          (windmove-right)))
   ("x" (lambda ()
          (interactive)
          (split-window-below)
          (windmove-down)))
   ("s" (ace-lambda 4))
   ("S" save-buffer)
   ("d" delete-window)
   ("D" (ace-lambda 16))
   ;("o" delete-other-windows)
   ("i" ace-maximize-window)
   ("z" (progn
          (winner-undo)
          (setq this-command 'winner-undo)))
   ("Z" winner-redo)
   ("SPC" nil)
   ) ;; `(define hydra-window)' ends here.
) ;;cl-macrolet ends here
   #+END_SRC

   #+RESULTS:
   : hydra-window/body

****** hydra-god-mode
 #+BEGIN_SRC emacs-lisp
(defhydra hydra-god-mode (:body-pre (message "god mode started")
                                  :post     (message "god mode exited."))
  "god mode"
  ("p" previous-line)
  ("n" next-line)
  ("b" backward-char)
          ("f" forward-char)
          ("a" doom/backward-to-bol-or-indent)
          ("e" doom/forward-to-last-non-comment-or-eol)
          ("j" electric-newline-and-maybe-indent)
          ("k" kill-line)
          ("o" open-line)
          ("ga" beginning-of-buffer)
          ("ge" end-of-buffer)
          ("q" nil "quit"))
#+END_SRC
****** hydra-modes
#+BEGIN_SRC emacs-lisp
(defhydra hydra-modes ( :color pink :exit t)
  "various major modes"
  ("t" text-mode "text mode")
  ("o" org-mode "org mode")
  ("w" writeroom-mode "writeroom mode")
  ("e" emacs-lisp-mode "elisp mode")
  ("g" hydra-god-mode/body "activate hydra-god-mode")
  ("q" nil "quit"))
#+END_SRC
**** here I use (map!)
#+BEGIN_SRC emacs-lisp
(map! :leader
      (:desc "modes" "m" #'hydra-modes/body)
      (:desc "hydra window" "C-w" #'hydra-window/body)
;;      (:desc "split window below" "2" #'hydra-window/body)
 ;;       (:desc "split window right" "3" #'split-window-right)
       (:prefix-map ("b" . "buffer")
                    (:desc "new buffer"            "n" #'+default/new-buffer)
                    (:desc "kill this buffer"      "k" #'kill-this-buffer))
       
 ;;       (:prefix-map ("t" . "toggle")
 ;;                    (:prefix-map ("t" . "telega")
 ;;                                 (:desc "start telega"       "t" (lambda () (interactive) (telega t)))
 ;;                                 ;(:desc "start telega"       "t" #'telega)
 ;;                                 (:desc "telega chat with"   "c" #'telega-chat-with)
 ;;                                 (:desc "kill telega"        "q" #'telega-kill)))
 ;;       (:prefix-map ("M-p" . "portage")
 ;;                    ))
)
#+END_SRC

**** global keys
 #+BEGIN_SRC emacs-lisp
 (global-set-key (kbd "C-\\") #'undo)
 #+END_SRC
** EXWM configuration
 #+BEGIN_SRC emacs-lisp
 ;map where the workspaces shall be
 (setq exwmsw-active-workspace-plist
       '("HDMI-1" 0 "HDMI-2" 0
         "LVDS-1" 1 "HDMI-2" 1
         "LVDS-1" 2 "HDMI-2" 2
         "LVDS-1" 3 "HDMI-2" 3
         "LVDS-1" 4 "HDMI-2" 4
         "LVDS-1" 5 "HDMI-2" 5
         "LVDS-1" 6 "HDMI-2" 6
         "LVDS-1" 7 "HDMI-2" 7))
 (setq exwmsw-the-right-screen "LVDS1")
 (setq exwmsw-the-center-screen "HDMI-2")
 (require 'exwm-systemtray)
 (exwm-systemtray-enable)
 #+END_SRC

*** define some helper functions
 efs stands for emacs from scratch since I +stole+ /borrowed/ this part from system crafters.
 but here they stand for exwm function sex
 #+BEGIN_SRC emacs-lisp
(defun efs/exwm-init-hook ()
  ;; Make workspace 1 be the one where we land at startup
  (exwm-workspace-switch-create 1))

(defun efs/exwm-update-class ()
  (exwm-workspace-rename-buffer exwm-class-name))

(defun efs/exwm-update-title ()
  (pcase exwm-class-name
    ("Librewolf" (exwm-workspace-rename-buffer (format "Librewolf: %s" exwm-title)))))

;; This function isn't currently used, only serves as an example how to
;; position a window
(defun efs/position-window ()
  (let* ((pos (frame-position))
         (pos-x (car pos))
          (pos-y (cdr pos)))

    (exwm-floating-move (- pos-x) (- pos-y))))

 (use-package exwm
   :config
   ;; Set the default number of workspaces
   (setq exwm-workspace-number 9)

   ;; When window "class" updates, use it to set the buffer name
   (add-hook 'exwm-update-class-hook #'efs/exwm-update-class)

   ;; When window title updates, use it to set the buffer name
   (add-hook 'exwm-update-title-hook #'efs/exwm-update-title)

   ;; Configure windows as they're created
   ;(add-hook 'exwm-manage-finish-hook #'efs/configure-window-by-class)

   ;; When EXWM starts up, do some extra confifuration
   (add-hook 'exwm-init-hook #'efs/exwm-init-hook)

   ;; NOTE: Uncomment the following two options if you want window buffers
   ;;       to be available on all workspaces!

   ;; Automatically move EXWM buffer to current workspace when selected
   (setq exwm-layout-show-all-buffers t)

   ;; Display all EXWM buffers in every workspace buffer list
   (setq exwm-workspace-show-all-buffers t)

   ;; NOTE: Uncomment this option if you want to detach the minibuffer!
   ;; Detach the minibuffer (show it with exwm-workspace-toggle-minibuffer)
   ;;(setq exwm-workspace-minibuffer-position 'top)

   ;; Set the screen resolution (update this to be the correct resolution for your screen!)
   (require 'exwm-randr)
   (exwm-randr-enable)

   ;; This will need to be updated to the name of a display!  You can find
   ;; the names of your displays by looking at arandr or the output of xrandr
      (setq exwm-randr-workspace-monitor-plist '(0 "HDMI-1"
                                                 1 "HDMI-2"
                                                 2 "HDMI-2"
                                                 3 "HDMI-2"
                                                 4 "HDMI-2"
                                                 5 "VGA1-1"
                                                 6 "LVDS-1"
                                                 7 "LVDS-1"
                                                 8 "LVDS-1"
                                                 9 "LVDS-1"))
   ;; Automatically send the mouse cursor to the selected workspace's display
   (setq exwm-workspace-warp-cursor t)

   ;; Window focus should follow the mouse pointer
   (setq mouse-autoselect-window t
         focus-follows-mouse t)

   ;; Ctrl+Q will enable the next key to be sent directly
   (define-key exwm-mode-map [?\C-q] 'exwm-input-send-next-key)

   ;; Set up global key bindings.  These always work, no matter the input state!
   ;; Keep in mind that changing this list after EXWM initializes has no effect.
   (setq exwm-input-global-keys
         `(
           ;; Reset to line-mode (C-c C-k switches to char-mode via exwm-input-release-keyboard)
           (,(kbd "s-r") . exwm-reset)

           ;; Move between windows
            (,(kbd "s-h") . windmove-left)
            (,(kbd "s-l") . windmove-right)
            (,(kbd "s-k") . windmove-up)
            (,(kbd "s-j") . windmove-down)
            (,(kbd "s-H") . shrink-window-horizontally)
            (,(kbd "s-L") . enlarge-window-horizontally)

           ;; Launch applications via shell command
           (,(kbd "s-p") . (lambda (command)
                        (interactive (list (read-shell-command "$ ")))
                        (start-process-shell-command command nil command)))

           ;; Switch workspace
           (,(kbd "s-w") . exwm-workspace-switch)
           (,(kbd "s-v") . +vterm/toggle)
           ;; 's-N': Switch to certain workspace with Super (Win) plus a number key (0 - 9)
           ,@(mapcar (lambda (i)
                       `(,(kbd (format "s-%d" i)) .
                         (lambda ()
                           (interactive)
                           (exwm-workspace-switch-create ,i))))
                     (number-sequence 0 9))))

     (cl-macrolet ((bwrapper (file &optional (title file))
                        `(lambda () (interactive)
                           (start-process-shell-command
                            ,title nil (expand-file-name ,file "~/.local/bin/"))))
                   (start (name)
                          `(lambda () (interactive)
                             (start-process ,name nil ,name))))
                          (map! :leader
                         (:prefix-map ("x" . "X11 applications")
                                      (:desc "brave wrapped"         "b" (bwrapper "brave"))
                                      (:desc "deltachat wrapped"     "d" (bwrapper "deltachat-desktop" "deltachat"))
                                      (:desc "whatsdesk wrapped"     "w" (bwrapper "whatsdesk"))
                                      (:desc "telegram wrapped"      "t" (bwrapper "telegram-desktop"))
                                      (:desc "lycheeslicer wrapped"  "M-l" (bwrapper "lycheeslicer"))
                                      (:desc "librewolf unwrapped"   "l" (start "librewolf"))
                                      ))
                   )
)

 #+END_SRC
** telega configuration
 this some configuration for telega

 #+BEGIN_SRC emacs-lisp
 (setq telega-server-libs-prefix "/usr")
 (add-hook 'telega-load-hook 'telega-notifications-mode)
 (add-hook 'telega-load-hook 'telega-appindicator-mode)
 (setq telega-appindicator-use-labels t)

 ;(setq telega-chat-input-markups '(nil "org" "markdown2"))
 (setq telega-chat-input-markups '("org" "markdown2"))
 (setq telega-directory (concat (getenv "XDG_DATA_HOME") "/telega"))
 (setq telega-emoji-font-family "Iosevka Nerd Font")
 (setq telega-emoji-use-images t)
 (add-hook 'telega-chat-mode-hook 'toggle-truncate-lines)
#+END_SRC
